# -*- python -*-
#     Copyright 2021, Kay Hayen, mailto:kay.hayen@gmail.com
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#

"""
The Nuitka scons file. If you have Scons or platform knowledge, please be
especially invited and contribute improvements.

This file is used to build an executable or shared library. Nuitka needs no
build process for itself, although it can be compiled using the same method.
"""

# Make nuitka package importable from calling installation

import sys
import os
import types

sys.modules["nuitka"] = types.ModuleType("nuitka")
sys.modules["nuitka"].__path__ = [os.environ["NUITKA_PACKAGE_DIR"]]

# We are in the build.build package really.
import nuitka.build  # pylint: disable=unused-import

__package__ = "nuitka.build"  # pylint: disable=redefined-builtin

# isort:start

import json
import subprocess

import SCons  # pylint: disable=I0021,import-error
from SCons.Script import (  # pylint: disable=I0021,import-error
    ARGUMENTS,
    Environment,
    GetOption,
)

from nuitka.Tracing import (
    my_print,
    scons_details_logger,
    scons_logger,
    setQuiet,
)
from nuitka.utils.Execution import check_output
from nuitka.utils.Utils import isDebianBasedLinux

from .SconsCaching import enableCcache, enableClcache
from .SconsCompilerSettings import (
    addConstantBlobFile,
    checkWindowsCompilerFound,
    decideConstantsBlobResourceMode,
    enableC11Settings,
    enableExperimentalSettings,
    enableLtoSettings,
    enableWindowsStackSize,
)
from .SconsHacks import (
    getEnhancedToolDetect,
    makeGccUseLinkerFile,
    myDetectVersion,
)
from .SconsProgress import enableSconsProgressBar, setSconsProgressBarTotal
from .SconsSpawn import enableSpawnMonitoring
from .SconsUtils import (
    addClangClPathFromMSVC,
    addToPATH,
    changeKeyboardInteruptToErrorExit,
    createDefinitionsFile,
    createEnvironment,
    getArgumentBool,
    getArgumentDefaulted,
    getArgumentList,
    getArgumentRequired,
    getExecutablePath,
    getMsvcVersion,
    getMsvcVersionString,
    initScons,
    isGccName,
    provideStaticSourceFile,
    raiseNoCompilerFoundErrorExit,
    scanSourceDir,
    setArguments,
    setupScons,
    switchFromGccToGpp,
    writeSconsReport,
)

# Set the arguments.
setArguments(ARGUMENTS)

# Set up the basic stuff.
initScons()

# The directory containing the C files generated by Nuitka to be built using
# scons. They are referred to as sources from here on.
source_dir = getArgumentRequired("source_dir")

# The directory containing Nuitka provided C files to be built and where it
# should be used.
nuitka_src = getArgumentRequired("nuitka_src")
static_src = os.path.join(source_dir, "static")

# The name of executable or extension module that we produce.
result_basepath = getArgumentRequired("result_name")

# The name of executable that we produce (in executable mode).
result_exe = getArgumentDefaulted("result_exe", None)

# The suffix for an extension module (in module mode).
module_suffix = getArgumentDefaulted("module_suffix", None)

# Full names shall be used, no remapping for cacheable filenames.
full_names = getArgumentBool("full_names", False)

# Module mode: Create a Python extension module, create an executable otherwise.
module_mode = getArgumentBool("module_mode", False)

# Debug mode: Less optimizations, debug information in the resulting binary.
debug_mode = getArgumentBool("debug_mode", False)

# Profiling mode: Outputs vmprof based information from program run.
profile_mode = getArgumentBool("profile_mode", False)

# Python version to target.
python_version_str = getArgumentRequired("python_version")
python_version = tuple(int(d) for d in python_version_str.split("."))

# The ABI flags to target.
abiflags = getArgumentDefaulted("abiflags", "")
python_abi_version = python_version_str + abiflags

nuitka_python = getArgumentBool("nuitka_python", False)

# Python debug mode: reference count checking, assertions in CPython core.
python_debug = getArgumentBool("python_debug", False)

# Full compatibility, even where it's stupid, i.e. do not provide information,
# even if available, in order to assert maximum compatibility. Intended to
# control level of compatibility to absurd.
full_compat_mode = getArgumentBool("full_compat", False)

# Experimental indications. Do things that are not yet safe to do.
experimental = getArgumentList("experimental", "")

# Tracing mode. Output program progress.
trace_mode = getArgumentBool("trace_mode", False)

# LTO mode: Use link time optimizations of g++ compiler if available and known
# good with the compiler in question. The 4.5 one didn't have good enough
# support, the compiled result would not run correctly.
lto_mode = getArgumentBool("lto_mode", False)

static_libpython = getArgumentDefaulted("static_libpython", "")
if static_libpython:
    assert os.path.exists(static_libpython), static_libpython

# Windows target mode: Compile for Windows. Used to be an option, but we
# no longer cross compile this way.
win_target = os.name == "nt"

noelf_mode = getArgumentBool("noelf_mode", False)

macosx_target = sys.platform == "darwin"

# Windows subsystem mode: Disable console for windows builds.
win_disable_console = getArgumentBool("win_disable_console", False)

# Windows might be running a Python whose DLL we have to use.
uninstalled_python = getArgumentBool("uninstalled_python", False)

# Unstriped mode: Do not remove debug symbols.
unstripped_mode = getArgumentBool("unstripped_mode", False)

# Target arch, uses for compiler choice and quick linking of constants binary
# data.
target_arch = ARGUMENTS["target_arch"]

# MinGW compiler mode, optional and interesting to Windows only.
mingw_mode = getArgumentBool("mingw_mode", False)

# Clang compiler mode, forced on macOS and FreeBSD (excluding PowerPC), optional on Linux.
clang_mode = getArgumentBool("clang_mode", False)

# Clang on Windows is always clang-cl for now.
clangcl_mode = False
if win_target and not mingw_mode and clang_mode:
    clang_mode = False
    clangcl_mode = True

# Shared library and compiled modules count, determines the need for the
# compiled module loader.
module_count = int(ARGUMENTS["module_count"])

# Frozen modules count, determines the need for the bytecode frozen
# modules loader.
frozen_modules = int(ARGUMENTS.get("frozen_modules", 0))

# Standalone mode
standalone_mode = getArgumentBool("standalone_mode", False)

# Onefile mode
onefile_mode = getArgumentBool("onefile_mode", False)

# Onefile temp mode
onefile_temp_mode = getArgumentBool("onefile_temp_mode", False)

forced_stdout_path = ARGUMENTS.get("forced_stdout_path", None)
forced_stderr_path = ARGUMENTS.get("forced_stderr_path", None)

# Show scons mode, output information about Scons operation
show_scons_mode = getArgumentBool("show_scons", False)
scons_details_logger.is_quiet = not show_scons_mode

if int(os.environ.get("NUITKA_QUIET", "0")):
    setQuiet()

# Home of Python to be compiled against, used to find include files and
# libraries to link against.
python_prefix = ARGUMENTS["python_prefix"]

# Forced MSVC version (windows-only)
msvc_version = ARGUMENTS.get("msvc_version")

no_python_warnings = getArgumentBool("no_python_warnings", False)

# sys.flags values to pass along
# python_sysflag_py3k_warning
python_sysflag_py3k_warning = getArgumentBool("python_sysflag_py3k_warning", False)
# python_sysflag_division_warning
python_sysflag_division_warning = getArgumentBool(
    "python_sysflag_division_warning", False
)
# python_sysflag_division_warning
python_sysflag_bytes_warning = getArgumentBool("python_sysflag_bytes_warning", False)
# python_sysflag_no_site
python_sysflag_no_site = getArgumentBool("python_sysflag_no_site", False)
# python_sysflag_verbose
python_sysflag_verbose = getArgumentBool("python_sysflag_verbose", False)
# python_sysflag_unicode
python_sysflag_unicode = getArgumentBool("python_sysflag_unicode", False)
# python_sysflag_utf8
python_sysflag_utf8 = getArgumentBool("python_sysflag_utf8", False)
# python_sysflag_optimize
python_sysflag_optimize = getArgumentBool("python_sysflag_optimize", False)
# python_sysflag_no_randomization
python_sysflag_no_randomization = getArgumentBool(
    "python_sysflag_no_randomization", False
)

# Preprocessor defines from plugins
cpp_defines = getArgumentList("cpp_defines", "")
link_libraries = getArgumentList("link_libraries", "")

# Mode to only output compiler information, for use in "nuitka --version"
# only.
compiler_version_mode = getArgumentBool("compiler_version", False)

assume_yes_for_downloads = getArgumentBool("assume_yes_for_downloads", False)

if getArgumentBool("progress_bar", True):
    enableSconsProgressBar()


def printCompilerVersionOutput(*args):
    if compiler_version_mode or show_scons_mode:
        my_print("Scons:", *args)


# Amount of jobs to use.
job_count = GetOption("num_jobs")

# Add environment specified compilers to the PATH variable.
if "CC" in os.environ:
    os.environ["CC"] = os.path.normpath(os.environ["CC"])

    if os.path.isdir(os.environ["CC"]):
        scons_logger.sysexit(
            "Error, the CC variable must point to file, not directory."
        )

    if os.path.sep in os.environ["CC"]:
        cc_dirname = os.path.dirname(os.environ["CC"])
        if os.path.isdir(cc_dirname):
            addToPATH(None, cc_dirname, prefix=True)

    if win_target and isGccName(os.path.basename(os.environ["CC"])):
        scons_details_logger.info(
            "Environment CC seems to be a gcc, enabling mingw_mode."
        )
        mingw_mode = True

    printCompilerVersionOutput("CC=%r" % os.environ["CC"])

# Patch the compiler detection.

gcc_version = None

Environment.Detect = getEnhancedToolDetect()


# Create Scons environment, the main control tool. Don't include "mingw" on
# Windows immediately, we will default to MSVC if available.
env = createEnvironment(
    mingw_mode=mingw_mode,
    msvc_version=msvc_version,
    target_arch=target_arch,
)

scons_details_logger.info("Initial CC: %r" % env.get("CC"))
scons_details_logger.info(
    "Initial CCVERSION: %r" % (env.get("CCVERSION"),),
)

if "CC" in os.environ:
    # If the environment variable CC is set, use that.
    env["CC"] = os.path.expanduser(os.environ["CC"])
    env["CCVERSION"] = None
elif clangcl_mode:
    # If possible, add Clang directory from MSVC if available.
    addClangClPathFromMSVC(env=env, target_arch=target_arch)

    env["CC"] = "clang-cl"
    env["LINK"] = "lld-link"

    env["CCVERSION"] = None
elif clang_mode:
    # If requested by the user, use the clang compiler, overriding what was
    # said in environment.

    env["CC"] = "clang"
    env["CCVERSION"] = None

# On Windows, in case MSVC was not found and not previously forced, use the
# winlibs MinGW64 as a download, and use it as a fallback.
env = checkWindowsCompilerFound(
    env=env,
    target_arch=target_arch,
    msvc_version=msvc_version,
    assume_yes_for_downloads=assume_yes_for_downloads,
)

the_compiler = env["CC"]
the_cc_name = os.path.normcase(os.path.basename(the_compiler))


scons_logger.info("Backend C compiler: %s (%s)." % (the_compiler, the_cc_name))

# Requested or user provided, detect if it's clang even from environment
if "clang" in the_cc_name and "-cl" not in the_cc_name:
    clang_mode = True
    env["CCVERSION"] = None

# We consider clang to be a form of gcc for the most things, they strive to
# be compatible.
gcc_mode = isGccName(the_cc_name) or clang_mode

# Only use MSVC if not already clear, we are using MinGW.
msvc_mode = win_target and not gcc_mode
mingw_mode = win_target and gcc_mode

scons_details_logger.info(
    "Modes for this compiler are: %r"
    % {
        "gcc_mode": gcc_mode,
        "clang_mode": clang_mode,
        "clangcl_mode": clangcl_mode,
        "mingw_mode": mingw_mode,
        "msvc_mode": msvc_mode,
    }
)

if gcc_mode and not clang_mode:
    gcc_version = myDetectVersion(env, the_compiler)

    if gcc_version is None:
        scons_logger.sysexit(
            """\
Error, failed to detect gcc version of backend compiler %r.
"""
            % the_compiler
        )

    if "++" in the_cc_name:
        scons_logger.sysexit(
            """\
Error, compiler %s is apparently a C++ compiler, specify a C compiler instead.
"""
            % the_cc_name
        )

    # Consider switching from gcc to its g++ compiler as a workaround that makes us work without C11.
    the_compiler, the_gcc_name = switchFromGccToGpp(
        gcc_version=gcc_version,
        the_compiler=the_compiler,
        the_cc_name=the_cc_name,
        env=env,
    )

if the_compiler is None or getExecutablePath(the_compiler, env=env) is None:
    raiseNoCompilerFoundErrorExit()

# Check if there is a WindowsSDK installed.
if msvc_mode or clangcl_mode:
    if "WindowsSDKVersion" not in env:
        if "WindowsSDKVersion" in os.environ:
            windows_sdk_version = os.environ["WindowsSDKVersion"].rstrip("\\")
        else:
            windows_sdk_version = None
    else:
        windows_sdk_version = env["WindowsSDKVersion"]

    scons_details_logger.info("Using Windows SDK %r." % windows_sdk_version)

    if not windows_sdk_version:
        scons_logger.sysexit(
            "Error, the Windows SDK must be installed in Visual Studio."
        )

# Do we use C11 for source files, or pretend to be C++ as a workaround.
c11_mode = enableC11Settings(
    env=env,
    clangcl_mode=clangcl_mode,
    msvc_mode=msvc_mode,
    clang_mode=clang_mode,
    gcc_mode=gcc_mode,
    gcc_version=gcc_version,
)

scons_details_logger.info("Using C11 mode: %s" % c11_mode)

no_import_lib = False

if show_scons_mode:
    my_print("Scons: Compiler used", end=" ")
    my_print(getExecutablePath(the_compiler, env=env), end=" ")

    if win_target and msvc_mode:
        my_print("(MSVC %s)" % getMsvcVersionString(env))

    my_print()

# Set build directory and scons general settings.
setupScons(env, source_dir)

if gcc_mode:
    # Support for gcc and clang, restricting visibility as much as possible.
    env.Append(CCFLAGS=["-fvisibility=hidden"])

    if not c11_mode:
        env.Append(CXXFLAGS=["-fvisibility-inlines-hidden"])

    if os.name == "nt":
        # On Windows, exporting to DLL need to be controlled.
        env.Append(LINKFLAGS=["-Wl,--exclude-all-symbols"])

        # Make sure we handle import library on our own and put it into the
        # build directory.
        env.Append(
            LINKFLAGS=["-Wl,--out-implib,%s" % os.path.join(source_dir, "import.lib")]
        )

    # Make it clear how to handle integer overflows, namely by wrapping around
    # to negative values.
    env.Append(CCFLAGS=["-fwrapv"])


# Support for clang.
if "clang" in the_cc_name:
    env.Append(CCFLAGS=["-w"])
    env.Append(CPPDEFINES=["_XOPEN_SOURCE"])

    # Don't export anything by default, this should create smaller executables.
    env.Append(CCFLAGS=["-fvisibility=hidden", "-fvisibility-inlines-hidden"])

    if debug_mode:
        env.Append(CCFLAGS=["-Wunused-but-set-variable"])

# Enable LTO for compiler.
lto_mode = enableLtoSettings(
    env=env,
    lto_mode=lto_mode,
    msvc_mode=msvc_mode,
    gcc_mode=gcc_mode,
    clang_mode=clang_mode,
    nuitka_python=nuitka_python,
    job_count=job_count,
)

if lto_mode and mingw_mode:
    scons_logger.warning(
        """The gcc and (also clang based on) it compiler on Windows, doesn't currently support lto mode. Disabled."""
    )

    lto_mode = False

# Support details for real gcc, not clang.
if gcc_mode and not clang_mode:
    # Enforce the minimum version, selecting a potentially existing g++-4.5
    # binary if it's not high enough. This is esp. useful under Debian which
    # allows all compiler to exist next to each other and where g++ might not be
    # good enough, but g++-4.5 would be.
    if gcc_version < (4, 4):
        scons_logger.sysexit(
            """\
The gcc compiler %s (version %s) doesn't have the sufficient \
version (>= 4.4)."""
            % (the_compiler, gcc_version)
        )

    # Older g++ complains about aliasing with Py_True and Py_False, but we don't
    # care.
    if gcc_version < (4, 5):
        env.Append(CCFLAGS=["-fno-strict-aliasing"])

    # For LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gcc_version < (4, 6):
        scons_logger.warning(
            """\
The gcc compiler %s (version %s) doesn't have the sufficient \
version for lto mode (>= 4.6). Disabled."""
            % (env["CXX"], env["CXXVERSION"])
        )

        lto_mode = False

    # CondaCC or newer.
    if mingw_mode and gcc_version < (5, 3):
        scons_logger.sysexit(
            """\
The MinGW64 compiler %s (version %s) doesn't have the sufficient \
version (>= 5.3)."""
            % (the_compiler, gcc_version)
        )

    # For gcc 4.6 there are some new interesting functions.
    if gcc_version >= (4, 6):
        env.Append(CCFLAGS=["-fpartial-inlining"])

        if debug_mode:
            env.Append(CCFLAGS=["-Wunused-but-set-variable"])

    # Use link time optimizations so that gcc can help with optimization across
    # files, but unfortunately at this time it seriously slows down the compiled
    # code. This may be because it needs -O3 option to be effective.
    if static_libpython and not lto_mode:
        env.Append(CCFLAGS=["-fno-lto"])
        env.Append(LINKFLAGS=["-fno-lto"])

    # Save some memory for gcc by not tracing macro code locations at all.
    if gcc_version >= (5,) and not debug_mode and not clang_mode:
        env.Append(CCFLAGS=["-ftrack-macro-expansion=0"])

    # We don't care about that.
    env.Append(CCFLAGS=["-Wno-deprecated-declarations"])

    # The var-tracking does not scale, disable it. Should we really need it, we
    # can enable it. TODO: Does this cause a performance loss?
    env.Append(CCFLAGS=["-fno-var-tracking"])

    # This disables output of notes, e.g. on struct alignment layout changes
    env.Append(CCFLAGS=["-fcompare-debug-second"])

if gcc_mode and lto_mode:
    if debug_mode:
        env.Append(LINKFLAGS=["-Og"])
    else:
        env.Append(LINKFLAGS=["-O2" if lto_mode and not nuitka_python else "-O3"])

    if not clang_mode:
        env.Append(LINKFLAGS=["-fpartial-inlining", "-freorder-functions"])


# Avoid them as appearing to be different files. TODO: Find out which
# clang version has this, clang-8 does not.
if gcc_mode and not clang_mode and gcc_version >= (8,):
    if source_dir != "." and not full_names:
        # TODO: This also lies for modules codes.
        env.Append(
            CCFLAGS=[
                "--file-prefix-map=%s=%s" % (os.path.normpath(source_dir), "."),
                "--file-prefix-map=%s=%s"
                % (
                    os.path.normpath(os.path.join(source_dir, "static_src")),
                    os.path.normpath(os.path.join(nuitka_src, "static_src")),
                ),
            ]
        )

if gcc_mode and not noelf_mode and not macosx_target:
    env.Append(LINKFLAGS=["-z", "noexecstack"])

if msvc_mode:
    # With Clang on Windows, there is also an linker to use.
    env.Append(
        CCFLAGS=[
            "/EHsc",  # No C++ exception handling code.
            "/J",  # default char type is unsigned.
            "/Gd",  # Use C calling convention by default.
            "/bigobj",  # Product object files with larger internal limits.
        ]
    )

    # No incremental linking.
    env.Append(LINKFLAGS=["/INCREMENTAL:NO"])

    if module_mode:
        # Make sure we handle import library on our own and put it into the
        # build directory.

        no_import_lib = True
        env.Append(
            LINKFLAGS=[
                "/INCREMENTAL:NO",
                "/IMPLIB:%s" % os.path.join(source_dir, "import.lib"),
            ]
        )

if not module_mode:
    enableWindowsStackSize(
        env=env, msvc_mode=msvc_mode, mingw_mode=mingw_mode, target_arch=target_arch
    )


# The 32 bits MinGW does not default for API level properly, so help it.
if mingw_mode:
    # Windows XP
    env.Append(CPPDEFINES=["_WIN32_WINNT=0x0501"])

if debug_mode:

    if gcc_mode:
        # Allow gcc/clang to point out all kinds of inconsistency to us by
        # raising an error.
        env.Append(
            CCFLAGS=[
                "-Wall",
                "-Werror",
                # Unfortunately Py_INCREF(Py_False) triggers aliasing warnings,
                # which are unfounded, so disable them.
                "-Wno-error=strict-aliasing",
                "-Wno-strict-aliasing",
                # At least for self-compiled Python3.2, and MinGW this happens
                # and has little use anyway.
                "-Wno-error=format",
                "-Wno-format",
            ]
        )

        if not clang_mode and gcc_version >= (6,):
            env.Append(
                CCFLAGS=[
                    # For large files, these can issue warnings about disabling
                    # itself, while we do not need it
                    "-Wno-misleading-indentation"
                ]
            )
    elif msvc_mode:
        # Disable warnings that system headers already show.
        env.Append(
            CCFLAGS=[
                "/W4",
                "/wd4505",
                "/wd4127",
                "/wd4100",
                "/wd4702",
                "/wd4189",
                "/wd4211",
                "/WX",
            ]
        )

        # Disable warnings, that CPython headers already show.
        if python_version >= (3, 4):
            env.Append(CCFLAGS=["/wd4512", "/wd4510", "/wd4610"])

        env.Append(CCFLAGS=["/wd4996"])

if full_compat_mode:
    env.Append(CPPDEFINES=["_NUITKA_FULL_COMPAT"])

if experimental:
    enableExperimentalSettings(env, experimental)

if profile_mode:
    env.Append(CPPDEFINES=["_NUITKA_PROFILE"])

if trace_mode:
    env.Append(CPPDEFINES=["_NUITKA_TRACE"])

if standalone_mode:
    env.Append(CPPDEFINES=["_NUITKA_STANDALONE"])

if onefile_mode:
    env.Append(CPPDEFINES=["_NUITKA_ONEFILE"])

if onefile_temp_mode:
    env.Append(CPPDEFINES=["_NUITKA_ONEFILE_TEMP"])

# We need "dl" in accelerated mode.
if "linux" in sys.platform:
    env.Append(LIBS=["dl"])

if not msvc_mode:
    env.Append(LIBS=["m"])

if win_target:
    # For MinGW and cross compilation, we need to tell the subsystem
    # to target as well as to automatically import everything used.
    if gcc_mode:
        if not clang_mode:
            env.Append(LINKFLAGS=["-Wl,--enable-auto-import"])

        if win_disable_console:
            env.Append(LINKFLAGS=["-Wl,--subsystem,windows"])

    if win_disable_console:
        env.Append(CPPDEFINES=["_NUITKA_WINMAIN_ENTRY_POINT"])

    if msvc_mode:
        # This is used for "GetCommandLineW" used in Windows code for Python3.
        if python_version >= (3,) or onefile_temp_mode:
            env.Append(LIBS=["Shell32"])

if python_debug:
    env.Append(CPPDEFINES=["Py_DEBUG"])

if static_libpython:
    env.Append(CPPDEFINES=["Py_NO_ENABLE_SHARED"])


def detectHostMultiarch():
    pipe = SCons.Action._subproc(  # pylint: disable=protected-access
        env,
        "dpkg-architecture",
        stdin="devnull",
        stderr="devnull",
        stdout=subprocess.PIPE,
    )

    for line in pipe.stdout:
        line = line.strip()

        if line.startswith("DEB_HOST_MULTIARCH="):
            return line.split("=", 1)[1]

    return None


if gcc_mode and "linux" in sys.platform:
    if python_version == (3, 3):
        host_multiarch = detectHostMultiarch()

        if host_multiarch is not None:
            env.Append(
                CCFLAGS=[
                    "-I"
                    + os.path.join(
                        "/usr/include/", host_multiarch, "python" + python_abi_version
                    )
                ]
            )


def _detectPythonHeaderPath():
    if win_target:
        # On Windows, the CPython installation layout is relatively fixed, but on MSYS2
        # compiled for mingw64, it's more standard.

        candidates = [
            os.path.join(python_prefix, "include"),
            # On MSYS2 with MinGW64 Python, it is also the other form.
            os.path.join(python_prefix, "include", "python" + python_abi_version),
        ]
    else:
        # The python header path is a combination of python version and debug
        # indication, we make sure the headers are found by adding it to the C
        # include path.

        candidates = [
            os.path.join(python_prefix, "include", "python" + python_abi_version)
        ]

    for candidate in candidates:
        if os.path.exists(os.path.join(candidate, "Python.h")):
            return candidate

    if win_target:
        scons_logger.sysexit(
            """Error, you seem to be using the unsupported embeddable CPython distribution."""
        )
    else:
        scons_logger.sysexit(
            """\
Error, no 'Python.h' %s headers can be found at '%s', dependency \
not satisfied!"""
            % ("debug" if python_debug else "development", candidates)
        )


env.Append(CPPPATH=[_detectPythonHeaderPath()])

# To support self-built Python on Windows, need to also add the "PC" directory,
# that a normal install won't have.
if os.name == "nt":
    python_header_path = os.path.join(python_prefix, "PC")

    if os.path.exists(python_header_path):
        env.Append(CPPPATH=[python_header_path])


def getWindowsPythonDLLPath():
    return os.environ["NUITKA_PYTHON_DLL_PATH"]


if nuitka_python:
    env.Append(CPPDEFINES=["_NUITKA_PYTHON"])

if static_libpython:
    env.Append(CPPDEFINES=["_NUITKA_STATIC_LIBPYTHON"])

if win_target:
    if nuitka_python:
        env.Append(
            LINKFLAGS=[
                "/LTCG",
                "/USEPROFILE:PGD=" + os.path.join(python_prefix, "python.pgd"),
            ]
        )

        with open(os.path.join(python_prefix, "link.json")) as f:
            linkData = json.load(f)
            env.Append(LIBS=linkData["libraries"])
            env.Append(LIBPATH=linkData["library_dirs"])
            for define, value in linkData["macros"]:
                if value:
                    env.Append(CPPDEFINES=[define + "=" + value])
                else:
                    env.Append(CPPDEFINES=[define])
    elif gcc_mode and static_libpython:
        env.Append(LIBS=[env.File(static_libpython)])
    else:
        # Some non standard Pythons on Windows have this.
        def addWinLib():
            # Make sure to locate the Python link library from multiple potential
            # locations (installed vs. self-built).
            if python_debug:
                win_lib_name = "python" + python_abi_version.replace(".", "") + "_d"
            else:
                win_lib_name = "python" + python_abi_version.replace(".", "")

            if python_version >= (3,):
                pc_build_dir = (
                    "PCBuild/amd64" if target_arch == "x86_64" else "PCBuild/win32"
                )
            else:
                pc_build_dir = "PCBuild"

            for candidate in ("libs", pc_build_dir):
                win_lib_path = os.path.join(python_prefix, candidate)

                if os.path.exists(os.path.join(win_lib_path, win_lib_name + ".lib")):
                    break
            else:
                scons_logger.sysexit("Error, cannot find '%s.lib' file." % win_lib_name)

            env.Append(LIBPATH=[win_lib_path])
            env.Append(LIBS=[win_lib_name])

        addWinLib()
elif not module_mode:
    # Add the python library path to the library path
    python_lib_path = os.path.join(python_prefix, "lib")
    env.Append(LIBPATH=[python_lib_path])

    if nuitka_python and "pgo-link" in experimental:
        # With Nuitka-Python, we do not use the static link library actually, but
        # instead we link against the object files, as otherwise gcc doesn't seem
        # to want to pick the profiling information up. TODO: This is not showing
        # any benefit over plain LTO yet.
        pgo_dir = os.path.join(python_prefix, "lib/pgo")

        env.Append(LINKFLAGS=["-fprofile-dir=%s" % pgo_dir])
        env.Append(LINKFLAGS=["-fprofile-correction"])

        for filename in check_output(["ar", "t", static_libpython]).splitlines():
            filename = os.path.join(pgo_dir, filename)

            if not filename.endswith(".o"):
                continue

            if os.path.basename(filename) in ("main.o", "python.o"):
                continue

            gcda_filename = filename[:-2] + ".gcda"

            if os.path.exists(gcda_filename):
                env.Append(
                    LINKFLAGS=["-fprofile-use=%s" % os.path.basename(gcda_filename)]
                )

            env.Append(LIBS=[env.File(filename)])
    elif static_libpython:
        env.Append(LIBS=[env.File(static_libpython)])

        # The linker won't succeed in searching for those for system Python of Debian
        # compiled Pythons. Help that. For self-compiled,
        if python_prefix == "/usr" and isDebianBasedLinux():
            env.Append(LIBS=["z", "m", "util", "pthread"])

            if python_version >= (3,):
                env.Append(LIBS=["expat"])

            env.Append(LINKFLAGS=["-Xlinker", "-export-dynamic", "-rdynamic"])
    else:
        # Debian and Ubuntu distinguish the system libraries like this.
        if (
            python_debug
            and python_prefix == "/usr"
            and python_version < (3,)
            and isDebianBasedLinux()
        ):
            env.Append(LIBS=["python" + python_abi_version + "_d"])
        else:
            env.Append(LIBS=["python" + python_abi_version])

    if python_prefix != "/usr" and "linux" in sys.platform:
        env.Append(LIBS=["dl", "pthread", "util", "rt", "m"])

        if gcc_mode and not clang_mode:
            env.Append(LINKFLAGS=["-export-dynamic"])

    # For NetBSD the rpath is required, on FreeBSD it's warned as unused.
    if "netbsd" in sys.platform:
        env.Append(LINKFLAGS=["-rpath=" + python_lib_path])
elif macosx_target and module_mode:
    env.Append(LINKFLAGS=["-undefined", "dynamic_lookup"])

# The static include files reside in Nuitka installation, which may be where
# the "nuitka.build" package lives.
nuitka_include = os.path.join(nuitka_src, "include")

if not os.path.exists(os.path.join(nuitka_include, "nuitka", "prelude.h")):
    scons_logger.sysexit(
        "Error, cannot locate Nuitka includes at '%s', this is a broken Nuitka installation."
        % nuitka_include
    )

# We have include files in the build directory and the static include directory
# that is located inside Nuitka installation.
env.Append(CPPPATH=[source_dir, nuitka_include, os.path.join(nuitka_src, "static_src")])

if debug_mode or unstripped_mode:
    # Use debug format, so we get good tracebacks from it.
    if gcc_mode:
        env.Append(LINKFLAGS=["-g"])
        env.Append(CCFLAGS=["-g"])
        env.Append(ASFLAGS=["-g"])

        if not clang_mode:
            env.Append(CCFLAGS=["-feliminate-unused-debug-types"])
    elif msvc_mode:
        env.Append(CCFLAGS=["/Z7"])

        # Higher MSVC versions need this for parallel compilation
        if job_count > 1 and getMsvcVersion(env) >= 11:
            env.Append(CCFLAGS=["/FS"])

        env.Append(LINKFLAGS=["/DEBUG"])
else:
    if gcc_mode:
        if macosx_target:
            env.Append(LINKFLAGS=["-Wno-deprecated-declarations"])
        elif not clang_mode:
            env.Append(LINKFLAGS=["-s"])

# When debugging, optimize less than when optimizing, when not remove
# assertions.
if debug_mode:
    if clang_mode or (gcc_mode and gcc_version >= (4, 8)):
        env.Append(CCFLAGS=["-Og"])
    elif gcc_mode:
        env.Append(CCFLAGS=["-O1"])
    elif msvc_mode:
        env.Append(CCFLAGS=["-O2"])
else:
    if gcc_mode:
        env.Append(CCFLAGS=["-O2" if lto_mode and not nuitka_python else "-O3"])

        # Check inlining of calls, except in debug mode, where it will all be
        # wrong due to additional code.
        # if not debug_mode:
        #     env.append(CCFLAGS = ["-Winline"])
    elif msvc_mode:
        env.Append(
            CCFLAGS=[
                "/Ox",  # Enable most speed optimization
                "/GF",  # Eliminate duplicate strings.
                "/Gy",  # Function level object storage, to allow removing unused ones
            ]
        )

    env.Append(CPPDEFINES=["__NUITKA_NO_ASSERT__"])

# MinGW for 64 bits needs this due to CPython bugs.
if win_target and target_arch == "x86_64" and gcc_mode:
    env.Append(CPPDEFINES=["MS_WIN64"])

# Set load libpython from binary directory default
if gcc_mode and not macosx_target and not win_target and not module_mode:
    if standalone_mode:
        rpath = "$$ORIGIN"
    else:
        rpath = python_lib_path

    env.Append(LINKFLAGS=["-Wl,-R,'%s'" % rpath])

    # The rpath is no longer used unless we do this on modern Linux. The
    # option name is not very revealing, but basically without this, the
    # rpath in the binary will be ignored by the loader.
    if "linux" in sys.platform:
        env.Append(LINKFLAGS=["-Wl,--disable-new-dtags"])

# For macOS we need to make sure install_name_tool can do its work
if macosx_target and not module_mode:
    env.Append(LINKFLAGS=["-headerpad_max_install_names"])

addConstantBlobFile(
    env=env,
    resource_desc=decideConstantsBlobResourceMode(
        gcc_mode=gcc_mode,
        clang_mode=clang_mode,
        lto_mode=lto_mode,
    ),
    source_dir=source_dir,
    c11_mode=c11_mode,
    mingw_mode=mingw_mode,
    target_arch=target_arch,
)

env.Append(CPPDEFINES=["_NUITKA_FROZEN=%d" % frozen_modules])

# Tell compiler to create a shared library or program.
if module_mode:
    if "gcc" in the_cc_name or "g++" in the_cc_name:
        env.Append(CCFLAGS=["-shared"])
    elif clang_mode:
        pass
    elif msvc_mode:
        env.Append(CCFLAGS=["/LD"])  # Create a DLL.
    else:
        assert False, the_cc_name
else:
    if msvc_mode:
        env.Append(CCFLAGS=["/MT"])  # Multithreaded, static version of C run time.


if module_mode:
    env.Append(CPPDEFINES=["_NUITKA_MODULE"])
else:
    env.Append(CPPDEFINES=["_NUITKA_EXE"])


def discoverSourceFiles():
    result = []

    # Scan for Nuitka created source files, and add them too.
    result.extend(
        scanSourceDir(env=env, c11_mode=c11_mode, dirname=source_dir, plugins=False)
    )
    result.extend(
        scanSourceDir(
            env=env,
            c11_mode=c11_mode,
            dirname=os.path.join(source_dir, "plugins"),
            plugins=True,
        )
    )

    static_src_filenames = []

    # Main program, unless of course it's a Python module/package we build.
    if not module_mode:
        static_src_filenames.append("MainProgram.c")

    # Compiled types.
    static_src_filenames.append("CompiledCellType.c")
    static_src_filenames.append("CompiledFunctionType.c")
    static_src_filenames.append("CompiledGeneratorType.c")

    # Helper codes.
    static_src_filenames.append("CompiledCodeHelpers.c")
    static_src_filenames.append("InspectPatcher.c")
    static_src_filenames.append("MetaPathBasedLoader.c")

    result += [
        provideStaticSourceFile(
            sub_path=filename,
            nuitka_src=nuitka_src,
            source_dir=source_dir,
            c11_mode=c11_mode,
        )
        for filename in static_src_filenames
    ]

    return result


source_files = discoverSourceFiles()

if module_mode:
    # For Python modules, the standard shared library extension is not what
    # gets used.
    env["SHLIBSUFFIX"] = module_suffix

    target = env.SharedLibrary(
        result_basepath, source_files, no_import_lib=no_import_lib
    )
else:
    target = env.Program(result_exe, source_files)

# Avoid dependency on MinGW libraries.
if win_target and gcc_mode and not clang_mode:
    env.Append(LINKFLAGS=["-static-libgcc"])

# Avoid IO for compilation as much as possible, this should make the
# compilation more memory hungry, but also faster.
if gcc_mode:
    env.Append(CCFLAGS="-pipe")

# Outside compiler settings are respected.
if "CPPFLAGS" in os.environ:
    scons_logger.info(
        "Scons: Inherited CPPFLAGS='%s' variable." % os.environ["CPPFLAGS"]
    )
    env.Append(CPPFLAGS=os.environ["CPPFLAGS"].split())
if "CCFLAGS" in os.environ:
    scons_logger.info("Inherited CCFLAGS='%s' variable." % os.environ["CCFLAGS"])
    env.Append(CCFLAGS=os.environ["CCFLAGS"].split())
if "CXXFLAGS" in os.environ:
    scons_logger.info(
        "Scons: Inherited CXXFLAGS='%s' variable." % os.environ["CXXFLAGS"]
    )
    env.Append(CXXFLAGS=os.environ["CXXFLAGS"].split())

# Outside linker flags are respected.
if "LDFLAGS" in os.environ:
    scons_logger.info("Scons: Inherited LDFLAGS='%s' variable." % os.environ["LDFLAGS"])
    env.Append(LINKFLAGS=os.environ["LDFLAGS"].split())

# Remove the target file to avoid cases where it falsely doesn't get rebuild
# and then lingers from previous builds,
if os.path.exists(target[0].abspath):
    os.unlink(target[0].abspath)

if show_scons_mode:
    my_print("Scons: Told to run compilation on %d CPUs." % job_count)


def createBuildDefinitionsFile():
    build_definitions = {}

    if uninstalled_python:
        if win_target:
            build_definitions["DLL_EXTRA_PATH"] = os.path.dirname(
                getWindowsPythonDLLPath()
            )

        build_definitions["PYTHON_HOME_PATH"] = python_prefix

    build_definitions["NO_PYTHON_WARNINGS"] = 1 if no_python_warnings else 0

    if python_version < (3,):
        build_definitions["SYSFLAG_PY3K_WARNING"] = (
            1 if python_sysflag_py3k_warning else 0
        )

        build_definitions["SYSFLAG_DIVISION_WARNING"] = (
            1 if python_sysflag_division_warning else 0
        )

        build_definitions["SYSFLAG_UNICODE"] = 1 if python_sysflag_unicode else 0

    build_definitions["SYSFLAG_BYTES_WARNING"] = (
        1 if python_sysflag_bytes_warning else 0
    )

    build_definitions["SYSFLAG_NO_SITE"] = 1 if python_sysflag_no_site else 0

    build_definitions["SYSFLAG_VERBOSE"] = 1 if python_sysflag_verbose else 0

    build_definitions["SYSFLAG_UTF8"] = 1 if python_sysflag_utf8 else 0

    build_definitions["SYSFLAG_OPTIMIZE"] = 1 if python_sysflag_optimize else 0

    build_definitions["SYSFLAG_NO_RANDOMIZATION"] = (
        1 if python_sysflag_no_randomization else 0
    )

    if forced_stdout_path:
        build_definitions["NUITKA_FORCED_STDOUT_PATH"] = forced_stdout_path
    if forced_stderr_path:
        build_definitions["NUITKA_FORCED_STDERR_PATH"] = forced_stderr_path

    createDefinitionsFile(source_dir, "build_definitions.h", build_definitions)


createBuildDefinitionsFile()

# The meta path based loader might want to respect that, so it does verbose traces in module
# mode, mostly for debugging purposes only.
if module_mode and python_sysflag_verbose:
    env.Append(CPPDEFINES=["_NUITKA_SYSFLAG_VERBOSE=1"])

if show_scons_mode:
    my_print("Scons: Launching target:", target)

# Hack to make Scons use tempfile for gcc linking, to avoid line length limits,
# which can make linking fail with many modules otherwise. Most needed on Windows,
# but useful on other platforms too.
if gcc_mode:
    makeGccUseLinkerFile(source_dir=source_dir, source_files=source_files, env=env)

# Plugin contributed C defines should be used too.
env.Append(CPPDEFINES=cpp_defines)
# Plugin contributed link libraries should be used too.
env.Append(LIBS=link_libraries)

# Work around windows bugs and use watchdogs to track progress of compilation.
enableSpawnMonitoring(
    env=env,
    win_target=win_target,
    module_mode=module_mode,
    lto_mode=lto_mode,
    source_files=source_files,
)

# Before we go, also lets turn KeyboardInterrupt into a mere error exit as the
# scons traceback is not going to be very interesting to us.
changeKeyboardInteruptToErrorExit()

# Check if ccache is installed, and complain if it is not.
if gcc_mode:
    enableCcache(
        the_compiler=the_compiler,
        env=env,
        source_dir=source_dir,
        python_prefix=python_prefix,
        assume_yes_for_downloads=assume_yes_for_downloads,
    )

if msvc_mode:
    enableClcache(
        the_compiler=the_compiler,
        env=env,
        source_dir=source_dir,
    )

writeSconsReport(
    source_dir=source_dir,
    env=env,
    gcc_mode=gcc_mode,
    clang_mode=clang_mode,
    msvc_mode=msvc_mode,
    clangcl_mode=clangcl_mode,
)

setSconsProgressBarTotal("Backend", len(source_files))

env.Default(target)
