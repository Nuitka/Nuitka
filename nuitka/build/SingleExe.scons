# -*- python -*-
#     Copyright 2013, Kay Hayen, mailto:kay.hayen@gmail.com
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#

# The Nuitka scons file. If you have Scons or platform knowledge, please feel free and
# contribute improvements, to do it the proper way.
#
# This file is used to build an executable or shared library. Nuitka needs no build
# process for itself, although it can be compiled using the same method.

import os, subprocess, sys, re

# The directory containing the C++ files generated by Nuitka to be built using scons. They are
# referred to as sources from here on.
source_name = ARGUMENTS[ "name" ]
source_dir = ARGUMENTS.get( "source_dir", source_name + ".build" )

# The directory containing Nuitka provided C++ files to be built.
nuitka_src = os.path.join( os.environ.get( "NUITKA_SCONS" ), "static_src" )
static_src = os.path.join( source_dir, "static" )

# We tell Scons that it is a variant to be built, so object files don't end up inside that
# directory which need not be writable.
VariantDir( static_src, nuitka_src, 0 )

# The name of what we should produce. By default it's the same as what we started with,
# but you (or Nuitka) could override it.
result_file = ARGUMENTS.get( "result_file", source_name )

def getBoolOption( option_name, default ):
    """ Small helper for boolean mode flags."""
    value = ARGUMENTS.get( option_name, "True" if default else "False" )

    return value.lower() in ( "yes", "true", "1" )


# Module mode: Create a Python extension module, create an executable otherwise.
module_mode = getBoolOption( "module_mode", False )

# Debug mode: Less optimizations, debug information in the resulting binary.
debug_mode = getBoolOption( "debug_mode", False )

# Optimization mode: Optimize as much as currently possible.
optimize_mode = getBoolOption( "optimize_mode", True )

# Full compatibility, even where it's stupid, i.e. do not provide information, even if
# available, in order to assert maximum compatbility. Intended to control level of
# compatability to absurd.
full_compat_mode = getBoolOption( "full_compat", False )

# Experimental mode. Do things that are not yet safe to do.
experimental_mode = getBoolOption( "experimental", False )

# LTO mode: Use link time optimizations of g++ compiler if available and known good with
# the compiler in question. The 4.5 one didn't have good enough support, the compiled
# result would not run correctly.
lto_mode = getBoolOption( "lto_mode", False )

# Windows target mode: Cross compile for Windows or compiling on windows.
win_target = getBoolOption( "win_target", os.name == "nt" )

# Windows subsystem mode: Disable console for windows builds.
win_disable_console = getBoolOption( "win_disable_console", False )

# ARM target mode: Compile for ARM which has bad ucontext status, we need
# to provide our own implementation.
arm_linux_target = getBoolOption( "arm_linux_target", "linux" in sys.platform and "arm" in os.uname()[4] )

# x64 target mode: Compile for x64 which swapcontext that does syscall that is not
# necessary. We choose to provide our own implementation.
x64_linux_target = getBoolOption( "x64_linux_target", "linux" in sys.platform and "x86_64" == os.uname()[4] and not win_target )

# Unstriped mode: Do not remove debug symbols.
unstriped_mode = getBoolOption( "unstriped_mode", False )

# Clang compiler mode, default on MacOS X and FreeBSD, optional on Linux.
clang_mode = getBoolOption( "clang_mode", False )
if sys.platform == "darwin" or "freebsd" in sys.platform:
    clang_mode = True

def createEnvironment( compiler_tools ):
    return Environment(
        # We want the outside environment to be passed through.
        ENV = os.environ,

        # Extra tools configuration for scons.
        tools = compiler_tools,

        # The shared libraries should not be named "lib...", because CPython requires the
        # filename "module_name.so" to load it.
        SHLIBPREFIX = "",
    )

def isExecutable( filename ):
    # Variable substitution from environment.
    if filename.startswith( "$" ):
        filename = env[ filename[1:] ]

    # Append exe suffix if not already present.
    if os.name == "nt" and not filename.lower().endswith( ".exe" ):
        filename += ".exe"

    # Search in PATH environment variable for a file named like it.
    for path_element in os.environ[ "PATH" ].split( ";" if os.name == "nt" else ":" ):
        full = os.path.join( path_element, filename )

        if os.path.exists( full ):
            return True
    else:
        return False


# Create Scons environment, the main control tool. Don't include "mingw" on Windows immediately,
# we will default to MSVC if available.
env = createEnvironment(
    compiler_tools = None if os.name == "nt" or not win_target else [ "mingw" ]
)

if clang_mode:
    # If requested by the user, use the clang compiler.
    env[ "CXX" ] = "clang"
elif "CXX" in os.environ:
    # If the environment variable CXX is set, use that.
    env[ "CXX" ] = os.environ[ "CXX" ]
elif win_target and not isExecutable( env[ "CXX" ] ):
    # The MingW compiler is attemted if no C++ compiler was found, in which case env[
    # "CXX" ] is still set, but not valid.
    env = createEnvironment(
        compiler_tools = [ "mingw" ]
    )


# To work around Windows not supporting command lines of greater than 10K by default:
def setupSpawn( env ):
    def spawn( sh, escape, cmd, args, env ):
        newargs = ' '.join(args[1:])
        cmdline = cmd + " " + newargs
        startupinfo = subprocess.STARTUPINFO()

        # CPython2.6 compatibility
        try:
            from subprocess import STARTF_USESHOWWINDOW
        except ImportError:
            from _subprocess import STARTF_USESHOWWINDOW

        startupinfo.dwFlags |= STARTF_USESHOWWINDOW

        proc = subprocess.Popen(
            cmdline,
            stdin       = subprocess.PIPE,
            stdout      = subprocess.PIPE,
            stderr      = subprocess.PIPE,
            startupinfo = startupinfo,
            shell       = False,
            env         = env
        )

        data, err = proc.communicate()
        rv = proc.wait()

        if cmd == "cl":
            data = data[ data.find( "\r\n" ) + 2 : ]
        elif cmd == "rc":
            data = data[ data.find( "reserved.\r" ) + 13 : ]
        elif cmd == "link" and module_mode:
            data = "\r\n".join( line for line in data.split( "\r\n" ) if "   Creating library" not in line )

        if data.rstrip():
            print cmdline
            print data,

        if rv:
            raise RuntimeError( err )

        return rv

    env[ "SPAWN" ] = spawn

def getGccVersion():
    # Update CXXVERSION in env, after we changed it.
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin  = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'[0-9]+(\.[0-9]+){2}', line )

    if match:
        return match.group(0)
    else:
        return None

def getClangVersion():
    import SCons

    pipe = SCons.Action._subproc(
        env, [ env[ "CXX" ], '--version' ],
        stdin  = 'devnull',
        stderr = 'devnull',
        stdout = subprocess.PIPE
    )

    line = pipe.stdout.readline()

    match = re.search( r'LLVM ([0-9]+(\.[0-9]+){1})', line )

    if match:
        return match.group(1)

    match = re.search( r'([0-9]+(\.[0-9]+){1})', line )

    if match:
        return match.group(1)
    else:
        return None


# To support cross-compiling under Linux for a  windows target, a cross compiler linked or
# installed to /opt/mingw will win over a system installed one.
if win_target and "linux" in sys.platform:
    if os.path.exists( "/opt/mingw/usr/bin/i686-pc-mingw32-g++" ):
        env[ "CXX" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-g++"
        env[ "RC" ] = "/opt/mingw/usr/bin/i686-pc-mingw32-windres"
    else:
        env[ "CXX" ] = "i586-mingw32msvc-g++"
        env[ "RC" ] = "i586-mingw32msvc-windres"

    # Update CXXVERSION in env, after we changed it.
    env[ "CXXVERSION" ] = getGccVersion()

orig_cxx = env[ "CXX" ]
orig_cxx_version = env.get( "CXXVERSION", None )

# Remove "g++" as the compiler, if it's not really existing or not good enough.
if "g++" in env[ "CXX" ]:
    gpp_version = getGccVersion()

    if gpp_version is None or int( getGccVersion().replace( ".", "" ) ) < 440:
        del env[ "CXX" ]

# Detect compiler to be used from supported ones, if there is no usable g++ link.
if os.name != "nt" and "CXX" not in env:
    for candidate in ( "g++-4.7", "g++-4.6", "g++-4.5", "g++-4.4", "clang" ):
        if os.path.exists( os.path.join( "/usr/bin", candidate ) ):
            env[ "CXX" ] = candidate

            if "clang" not in candidate:
                # Update CXXVERSION in env, after we changed it.
                env[ "CXXVERSION" ] = getGccVersion()

            break
    else:
        sys.exit( "The g++ compiler '%s' (version %s) doesn't have the sufficient version (>= 4.4)." % ( orig_cxx, orig_cxx_version ) )

gcc_mode = "g++" in env[ "CXX" ] or "clang" in env[ "CXX" ]
msvc_mode = win_target and not gcc_mode

if os.name == "nt":
    setupSpawn( env )

env[ "BUILD_DIR" ] = source_dir

# Store the file signatures database with the rest of the source files
sconsign_dir = os.path.abspath( os.path.join( source_dir, '.sconsign' ) )

if not os.path.exists( sconsign_dir ):
    os.makedirs( sconsign_dir )

env.SConsignFile( sconsign_dir )

# Support for clang.
if "clang" in env[ "CXX" ]:
    env.Append( CCFLAGS = [ "-w" ] )
    env.Append( CPPDEFINES = [ "_XOPEN_SOURCE" ] )
    env.Append( LINKFLAGS = [ "-lstdc++" ])

    # Don't export anything by default, this should create smaller executables.
    env.Append( CCFLAGS = [ "-fvisibility=hidden", "-fvisibility-inlines-hidden" ] )

    if debug_mode:
        env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    clang_version = getClangVersion()
    clang_version = int( clang_version.replace( ".", "" ) + "0" )

# Support for g++.
if "g++" in env[ "CXX" ]:
    # Don't export anything by default, this should create smaller executables.
    if not win_target:
        env.Append( CCFLAGS = [ "-fvisibility=hidden", "-fvisibility-inlines-hidden" ] )

    env[ "CXXVERSION" ] = getGccVersion()

    # Version dependent options.
    gpp_version = int( env[ "CXXVERSION" ].replace( ".", "" ) )

    # Enforce the minimum version, selecting a potentially existing g++-4.5 binary if it's
    # not high enough. This is esp. useful under Debian which allows all compiler to exist
    # next to  each other and where g++ might not be good enough, but g++-4.5 would be.
    if gpp_version < 440:
        sys.exit( "The g++ compiler %s (version %s) doesn't have the sufficient version (>= 4.5)." % ( env[ "CXX" ], env[ "CXXVERSION" ] ) )

    # Older g++ complains about aliasing with Py_True and Py_False, but we don't care.
    if gpp_version < 450:
        env.Append( CCFLAGS = [ "-fno-strict-aliasing" ] )

    # For LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gpp_version < 460 and not win_target and os.path.exists( "/usr/bin/g++-4.6" ):
        env[ "CXX" ] = "g++-4.6"
        gpp_version = 460

    # For g++ 4.6 there are some new interesting functions.
    if gpp_version >= 460:
        env.Append( CCFLAGS = [ "-fpartial-inlining" ] )

        if debug_mode:
            env.Append( CCFLAGS = [ "-Wunused-but-set-variable" ] )

    # Use link time optimizations so that gcc can help with optimization across files,
    # but unfortunately at this time it seriously slows down the compiled code. This may
    # be because it needs -O3 option to be effective.

    if gpp_version >= 460 and lto_mode:
        env.Append( CCFLAGS = [ "-flto" ] )
        env.Append( LINKFLAGS = [ "-flto=%d" % GetOption( "num_jobs" ) ] )

        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=noreturn" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=pure" ] )
        # env.Append( LINKFLAGS = [ "-Wsuggest-attribute=const" ] )
        # env.Append( CCFLAGS = [ "-Wnoexcept" ] )

        if debug_mode:
            env.Append( LINKFLAGS = [ "-O2" ] )

        if optimize_mode:
            env.Append( LINKFLAGS = [
                "-O3",
                "-fpartial-inlining",
                "-freorder-functions",
            ]
        )

    # Give a warning if LTO mode was specified, but won't be used.
    if lto_mode and gpp_version < 460:
        print >> sys.stderr, "Warning, LTO mode specified, but not available."

    # The var-tracking does not scale, disable it. Should we really need it, we can enable
    # it.
    env.Append( CCFLAGS = [ "-fno-var-tracking" ] )

if msvc_mode:
    env.Append( CCFLAGS = [ "/EHsc", "/J", "/Gd" ] )
    env.Append( LINKFLAGS = [ "/INCREMENTAL:NO" ] )

if debug_mode:

    if gcc_mode:
        # Allow g++/clang to point out all kinds of inconsistency to us by raising an error.
        env.Append( CCFLAGS = [ "-Wall", "-Werror" ] )
    elif msvc_mode:
        # Disable warnings that system headers already show
        env.Append( CCFLAGS = [ "/W4", "/wd4505", "/wd4127", "/wd4100", "/wd4702", "/wd4189" ] )


    # As for sequence points, we are abusing it, so we have to allow it.
    if "g++" in env[ "CXX" ]:
        env.Append( CCFLAGS = [ "-Wno-sequence-point" ] )

    # Benefit from clang checking memory accesses.
    if "clang" in env[ "CXX" ] and clang_version >= 330:
        env.Append( CCFLAGS = [ "-fsanatize=address,bounds,return" ] )

if full_compat_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_FULL_COMPAT" ] )

if experimental_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_EXPERIMENTAL" ] )

# Python version, use the scons one if not given.
python_version = ARGUMENTS.get( "python_version", None )

if python_version is None:
    python_version = "%d.%d" % ( sys.version_info[0], sys.version_info[1] )

if win_target:
    python_version = python_version.replace( ".", "" )

    def guessPythonHome():
        """ Guess the Python home directory.

        Under Windows it can be done from the running Python under Windows. Under
        Linux we take the supposed wine path. Can be overridden by an environment
        variable in any case.
        """

        if os.name == "nt":
            return os.path.dirname( sys.executable )
        else:
            return os.path.expanduser( "~/.wine/drive_c/Python" + python_version )

    python_home = os.environ.get( "PYTHON_HOME", guessPythonHome() )

    env.Append( LIBPATH = [ os.path.join( python_home, "libs" ) ] )

    if gcc_mode:
        env.Append( LINKFLAGS = [ "-Wl,--enable-auto-import" ] )

        if win_disable_console:
            env.Append( LINKFLAGS = [ "-Wl,--subsystem,windows" ] )

    python_header_path = os.path.join( python_home, "include" )

else:
    # The python header path is a combination of python version and debug indication, make
    # sure the headers are found by adding it to the C++ include path.
    python_header_path = "/usr/include/python" + python_version

    # If that directory doesn't exist, give it another shot, under /usr/local
    if not os.path.exists( python_header_path ):
        alternate_path = "/usr/local/include/python" + python_version

        if os.path.exists( alternate_path ):
            python_header_path = alternate_path

    # The Python library path is not in the standard path for freebsd.
    if "freebsd" in sys.platform:
        env.Append( LIBPATH = [ "/usr/local/lib" ] )

if not os.path.exists( os.path.join( python_header_path, "Python.h" ) ):
    sys.exit( "Error, no 'Python.h' development headers can be found at '%s', dependency not satisfied!" % python_header_path )

env.Append( CPPPATH  = [ python_header_path ] )

def detectHostMultiarch():
    import commands

    for line in commands.getoutput( "dpkg-architecture" ).split("\n"):
        if line.startswith( "DEB_HOST_MULTIARCH=" ):
            return line.split( "=", 1 )[1]
    else:
        return None

if gcc_mode and "linux" in sys.platform:
    if python_version.startswith( "3.3" ):
        host_multiarch = detectHostMultiarch()

        if host_multiarch is not None:
            env.Append( CCFLAGS = [ "-I/usr/include/" + host_multiarch + "/python" + python_version ] )

env.Append( LIBS = [ "python" + python_version ] )

nuitka_include = os.path.join( os.environ[ "NUITKA_SCONS" ], "include" )
env.Append( CPPPATH = [ source_dir, nuitka_include ] )

if debug_mode or unstriped_mode:
    # On crosscompile, use debug format that wine understands, so we get good tracebacks
    # from it.
    if gcc_mode:
        if win_target and "linux" in sys.platform:
            env.Append( CCFLAGS = [ "-gstabs" ] )
            env.Append( ASFLAGS = [ "-gstabs" ] )
        else:
            env.Append( CCFLAGS = [ "-g" ] )
            env.Append( ASFLAGS = [ "-g" ] )

            if "g++" in env[ "CXX" ]:
                env.Append( CCFLAGS = [ "-feliminate-unused-debug-types" ] )
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/Zi" ] )
        env.Append( LINKFLAGS = [ "/DEBUG" ] )

# When debugging, optimize less than when optimizing, when not remove assertions.
if debug_mode:
    if not optimize_mode:
        if gcc_mode or msvc_mode:
            env.Append( CCFLAGS = [ "-O2" ] )
else:
    env.Append( CPPDEFINES = [ "__NUITKA_NO_ASSERT__" ] )

if optimize_mode:
    if gcc_mode:
        env.Append( CCFLAGS = [ "-O3" ] )
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/Ox" ] )

# Tell compiler to create a shared library or program.
if module_mode:
    if "g++" in env[ "CXX" ]:
        env.Append( CCFLAGS = [ "-shared" ] )
    elif "clang" in env[ "CXX" ]:
        pass
    elif msvc_mode:
        env.Append( CCFLAGS = [ "/LD" ] )
    else:
        assert False
else:
    if msvc_mode:
        env.Append( CCFLAGS = [ "/MT" ])

if module_mode:
    env.Append( CPPDEFINES = [ "_NUITKA_MODULE" ] )
else:
    env.Append( CPPDEFINES = [ "_NUITKA_EXE" ] )

def discoverSourceFiles():
    result = []

    def getStatic( sub_path):
       return os.path.join( static_src, sub_path.replace( "/", os.path.sep ) )

    result.append( getStatic( "CompiledFunctionType.cpp" ) )
    result.append( getStatic( "CompiledGeneratorType.cpp" ) )
    result.append( getStatic( "CompiledMethodType.cpp" ) )
    result.append( getStatic( "CompiledFrameType.cpp" ) )
    result.append( getStatic( "CompiledCodeHelpers.cpp" ) )
    result.append( getStatic( "InspectPatcher.cpp" ) )

    if win_target:
        result.append( getStatic( "win32_ucontext_src/fibers_win32.cpp" ) )
    elif x64_linux_target:
        result.append( getStatic( "x64_ucontext_src/fibers_x64.cpp" ) )
        result.append( getStatic( "x64_ucontext_src/swapfiber.S" ) )
    elif arm_linux_target:
        result.append( getStatic( "arm_ucontext_src/fibers_arm.cpp" ) )
        result.append( getStatic( "arm_ucontext_src/ucontext.cpp" ) )
        result.append( getStatic( "arm_ucontext_src/getcontext.asm"  ) )
    else:
        # Variant based on getcontext/setcontext/swapcontext/makecontext
        result.append( getStatic(  "gen_ucontext_src/fibers_gen.cpp" ) )

    module_count = 0

    for filename in os.listdir( source_dir ):
        if filename.endswith( ".cpp" ):
            result.append( os.path.join( source_dir, filename ) )

            if filename.startswith( "module." ):
                module_count += 1

    # If more than one module is included, we need the unfreezer.
    if module_count > 1:
        result.append( static_src + "/ModuleUnfreezer.cpp" )

    # Add the resource file for the manifest to be included in the executable.
    if win_target and not module_mode:
        result.append( env.RES( os.path.join( source_dir, source_name + ".exe.rc" ) ) )

    return result

# Prepare the use of a custom specs file for windows targets. We change the used specs for
# linking to avoid the use of the wrong (for CPython) run time library.
if win_target and not module_mode:
    manifest_file = open( os.path.join(source_dir, source_name + ".exe.manifest" ), "w" )
    manifest_file.write( r"""
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"></requestedExecutionLevel>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
         type="win32"
         name="Microsoft.VC90.CRT"
         version="9.0.21022.8"
         processorArchitecture="x86"
         publicKeyToken="1fc8b3b9a1e18e3b">
      </assemblyIdentity>
    </dependentAssembly>
  </dependency>
</assembly>
"""
    )
    manifest_file.close()

    rc_file = open( os.path.join( source_dir, source_name + ".exe.rc" ), "w" )
    rc_file.write( r"""
#include "winuser.h"
1 RT_MANIFEST %s
""" % ( source_name + ".exe.manifest" )
    )
    rc_file.close()

if module_mode:
    if win_target:
        module_suffix = ".pyd"
    else:
        module_suffix = ".so"

    env[ "SHLIBSUFFIX" ] = module_suffix

    target = env.SharedLibrary( result_file, discoverSourceFiles() )
else:
    # Avoid dependency on MinGW libraries.
    if win_target and gcc_mode:
        env.Append( LINKFLAGS = [ "-static-libgcc",  "-static-libstdc++" ] )

    target = env.Program( result_file + ".exe", discoverSourceFiles() )

# Remove the target file to avoid cases where it falsely didn't get rebuilt.
if os.path.exists( target[0].abspath ):
    os.unlink( target[0].abspath )

Default( target )
