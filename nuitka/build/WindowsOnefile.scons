# -*- python -*-
#     Copyright 2020, Kay Hayen, mailto:kay.hayen@gmail.com
#
#     Part of "Nuitka", an optimizing Python compiler that is compatible and
#     integrates with CPython, but also works on its own.
#
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#

"""
The Onefile scons file for Windows, check out Backend.scons for where the
actual compiled binaries are build. If you have Scons or Windows platform
knowledge, please be especially invited and contribute improvements.

This file is used to build a bootstrap binary that only unpacks the Python
DLL and other data files needed, to have a onefile solution for Windows.
"""

# Make nuitka package importable from calling installation

import sys
import os
import types

sys.modules["nuitka"] = types.ModuleType("nuitka")
sys.modules["nuitka"].__path__ = [os.environ["NUITKA_PACKAGE_DIR"]]

# We are in the build.build package really.
import nuitka.build  # pylint: disable=unused-import

__package__ = "nuitka.build"  # pylint: disable=redefined-builtin

# isort:start

from SCons.Script import (  # pylint: disable=import-error
    ARGUMENTS,
    CacheDir,
    Decider,
    Default,
    Environment,
    GetOption,
)

from nuitka.Tracing import my_print, scons_logger

from .SconsCaching import enableCcache, enableClcache
from .SconsCompilerSettings import enableC11Settings
from .SconsHacks import getEnhancedToolDetect, myDetectVersion
from .SconsSpawn import getWindowsSpawnFunction, getWrappedSpawnFunction
from .SconsUtils import (
    addClangClPathFromMSVC,
    addToPATH,
    changeKeyboardInteruptToErrorExit,
    createDefinitionsFile,
    getArgumentBool,
    getArgumentDefaulted,
    getArgumentList,
    getArgumentRequired,
    getExecutablePath,
    getMsvcVersion,
    getMsvcVersionString,
    initScons,
    isGccName,
    provideStaticSourceFile,
    setArguments,
    writeSconsReport,
)

# Set the arguments.
setArguments(ARGUMENTS)

# Set up the basic stuff.
initScons()

# The directory containing the C files generated by Nuitka to be built using
# scons. They are referred to as sources from here on.
source_dir = getArgumentRequired("source_dir")

# The directory containing Nuitka provided C files to be built and where it
# should be used.
nuitka_src = getArgumentRequired("nuitka_src")
static_src = os.path.join(source_dir, "static")

# The name of executable or extension module that we produce.
result_basepath = getArgumentRequired("result_name")

# The name of executable that we produce (in executable mode).
result_exe = getArgumentDefaulted("result_exe", None)

# The suffix for an extension module (in module mode).
module_suffix = getArgumentDefaulted("module_suffix", None)

# Full names shall be used, no remapping for cacheable filenames.
full_names = getArgumentBool("full_names", False)

# The directory to use for cache directory.
cache_mode = getArgumentBool("cache_mode", False)

# Module mode: Create a Python extension module, create an executable otherwise.
module_mode = getArgumentBool("module_mode", False)

# Debug mode: Less optimizations, debug information in the resulting binary.
debug_mode = getArgumentBool("debug_mode", False)

# Experimental indications. Do things that are not yet safe to do.
experimental = getArgumentList("experimental", "")

# Tracing mode. Output program progress.
trace_mode = getArgumentBool("trace_mode", False)

# LTO mode: Use link time optimizations of g++ compiler if available and known
# good with the compiler in question. The 4.5 one didn't have good enough
# support, the compiled result would not run correctly.
lto_mode = getArgumentBool("lto_mode", False)

# Windows target mode: Compile for Windows. Used to be an option, but we
# no longer cross compile this way.
win_target = os.name == "nt"

# Windows subsystem mode: Disable console for windows builds.
win_disable_console = getArgumentBool("win_disable_console", False)

# Unstriped mode: Do not remove debug symbols.
unstripped_mode = getArgumentBool("unstripped_mode", False)

# Target arch, uses for compiler choice and quick linking of constants binary
# data.
target_arch = ARGUMENTS["target_arch"]

# Clang compiler mode, forced on macOS and FreeBSD (excluding PowerPC), optional on Linux.
clang_mode = getArgumentBool("clang_mode", False)

# Clang on Windows is always clang-cl for now.
clangcl_mode = False
if win_target and clang_mode:
    clang_mode = False
    clangcl_mode = True

# MinGW compiler mode, optional and interesting to Windows only.
mingw_mode = getArgumentBool("mingw_mode", False)

# Show scons mode, output information about Scons operation
show_scons_mode = getArgumentBool("show_scons", False)

# Home of Python to be compiled against, used to find tools like clcache and
# ccache.
python_prefix = ARGUMENTS["python_prefix"]

# Forced MSVC version (windows-only)
msvc_version = ARGUMENTS.get("msvc_version", None)

# Preprocessor defines from plugins
cpp_defines = getArgumentList("cpp_defines", "")
link_libraries = getArgumentList("link_libraries", "")

# Mode to only output compiler information, for use in "nuitka --version"
# only.
compiler_version_mode = getArgumentBool("compiler_version", False)

assume_yes_for_downloads = getArgumentBool("assume_yes_for_downloads", False)


def printCompilerVersionOutput(*args):
    if compiler_version_mode or show_scons_mode:
        my_print("Scons:", *args)


# Amount of jobs to use.
job_count = GetOption("num_jobs")

# Add environment specified compilers to the PATH variable.
if "CC" in os.environ:
    os.environ["CC"] = os.path.normpath(os.environ["CC"])

    if os.path.isdir(os.environ["CC"]):
        sys.exit("Error, the CC variable must point to file, not directory.")

    cc_dirname = os.path.dirname(os.environ["CC"])

    if win_target and isGccName(os.path.basename(os.environ["CC"])):
        if show_scons_mode:
            my_print("Scons: Environment CC seems to be a gcc, enable mingw_mode.")
        mingw_mode = True

    if os.path.isdir(cc_dirname):
        addToPATH(None, cc_dirname, prefix=True)

    printCompilerVersionOutput("CC=%r" % os.environ["CC"])

if "CXX" in os.environ:
    os.environ["CXX"] = os.path.normpath(os.environ["CXX"])

    if os.path.isdir(os.environ["CXX"]):
        sys.exit("Error, the CXX variable must point to file, not directory.")

    cxx_dirname = os.path.dirname(os.environ["CXX"])

    if win_target and isGccName(os.path.basename(os.environ["CXX"])):
        if show_scons_mode:
            my_print("Scons: Environment CXX seems to be a gcc, enable mingw_mode.")
        mingw_mode = True

    if os.path.isdir(cxx_dirname):
        os.environ["PATH"] = os.pathsep.join(
            [cxx_dirname] + os.environ["PATH"].split(os.pathsep)
        )

    printCompilerVersionOutput("CXX=%r" % os.environ["CXX"])


# Patch the compiler detection.

gcc_version = None

Environment.Detect = getEnhancedToolDetect(show_scons_mode)


def createEnvironment(tools):
    args = {}

    # If we are on Windows, and MinGW is not enforced, lets see if we can
    # find "cl.exe", and if we do, disable automatic scan.
    if (
        win_target
        and not mingw_mode
        and (
            getExecutablePath("cl", env=None) is not None
            or getExecutablePath("gcc", env=None) is not None
        )
    ):
        args["MSVC_USE_SCRIPT"] = False

    return Environment(
        # We want the outside environment to be passed through.
        ENV=os.environ,
        # Extra tools configuration for scons.
        tools=tools,
        # Under windows, specify the target architecture is needed for Scons
        # to pick up MSVC.
        TARGET_ARCH=target_arch,
        MSVC_VERSION=msvc_version,
        **args
    )


def getCompilerTools():
    if mingw_mode:
        # Force usage of MinGW, disable MSVC tools.
        compiler_tools = ["mingw"]

        import SCons.Tool.MSCommon.vc  # pylint: disable=I0021,import-error

        SCons.Tool.MSCommon.vc.msvc_setup_env = lambda *args: None

    else:
        # Everything else should use default.
        compiler_tools = ["default"]

    printCompilerVersionOutput("Tools=", compiler_tools)

    return compiler_tools


# Create Scons environment, the main control tool. Don't include "mingw" on
# Windows immediately, we will default to MSVC if available.
env = createEnvironment(tools=getCompilerTools())

if show_scons_mode:
    my_print("Scons: Initial CC:", env.get("CC", None))
    my_print("Scons: Initial CCVERSION:", env.get("CCVERSION", None))
    my_print("Scons: Initial CXX:", env.get("CXX", None))
    my_print("Scons: Initial CXXVERSION:", env.get("CXXVERSION", None))

if "CC" in os.environ:
    # If the environment variable CC is set, use that.
    env["CC"] = os.path.expanduser(os.environ["CC"])
    env["CCVERSION"] = None
elif clangcl_mode:
    # If possible, add Clang directory from MSVC if available.
    addClangClPathFromMSVC(
        env=env, target_arch=target_arch, show_scons_mode=show_scons_mode
    )

    env["CC"] = "clang-cl"
    env["LINK"] = "lld-link"

    env["CCVERSION"] = None
elif clang_mode:
    # If requested by the user, use the clang compiler, overriding what was
    # said in environment.

    env["CC"] = "clang"
    env["CCVERSION"] = None


the_compiler = env["CC"] or env["CXX"]
the_cc_name = os.path.normcase(os.path.basename(the_compiler))

scons_logger.info("Backend C compiler: %s (%s)." % (the_compiler, the_cc_name))

# Requested or user provided, detect if it's clang even from environment
if "clang" in the_cc_name and "-cl" not in the_cc_name:
    clang_mode = True
    env["CCVERSION"] = None

# We consider clang to be a form of gcc for the most things, they strive to
# be compatible.
gcc_mode = isGccName(the_cc_name) or clang_mode

# Make a check, to discover the currently unsupported combination.
if clangcl_mode and gcc_mode:
    sys.exit(
        """\
Error, you cannot combine a gcc C compiler with clang on Windows with Nuitka
yet. So far it was found to be only slower than pure MinGW64. If you want
to use it, you need to install Visual Studio, and use it instead, then the
clang mode will piggy back it.
"""
    )

# Only use MSVC if not already clear, we are using MinGW.
msvc_mode = win_target and not gcc_mode
mingw_mode = win_target and gcc_mode

if gcc_mode and not clang_mode:
    gcc_version = myDetectVersion(env, the_compiler)

    if gcc_version is None and "++" in the_cc_name:
        sys.exit(
            """\
Error, compiler %s is apparently a C++ compiler, specify a C compiler instead.
"""
            % the_cc_name
        )

    if gcc_version is not None and gcc_version < (5,):
        # Switch to g++ from gcc then if possible, when C11 mode is false.
        the_gpp_compiler = os.path.join(
            os.path.dirname(the_compiler),
            os.path.basename(the_compiler).replace("gcc", "g++"),
        )

        if getExecutablePath(the_gpp_compiler, env=env):
            the_compiler = the_gpp_compiler
            the_cc_name = the_cc_name.replace("gcc", "g++")
        else:
            sys.exit(
                "Error, you gcc is too old for C11 support, and no related g++ to workaround that is found."
            )

if the_compiler is None or getExecutablePath(the_compiler, env=env) is None:
    if win_target:
        sys.exit(
            """\
Error, cannot locate suitable C compiler. You have the following options:

a) If a suitable Visual Studio version is installed, it will not be located
   automatically, unless you install pywin32 for the Python installation
   below "%s".

b) To make it find Visual Studio without registry execute from Start Menu
   the 'Visual Studio Command Prompt' or "vcvarsall.bat". That will add
   Visual Studio to the "PATH". And it then will be detected.

c) Install MinGW64 to "C:\\MinGW64" or "\\MinGW64", where then it is
   automatically detected or manually add it to PATH before executing
   Nuitka. But be sure to pick the proper variant (32/64 bits, your
   Python arch is %r), or else cryptic errors will be shown.

Normal MinGW will not work! MinGW64 does *not* mean 64 bits, just better
Windows compatibility.
Cygwin based gcc will not work.
MSYS2 based gcc will not work.

Note: The clang-cl will only work if MSVC already works for you.
"""
            % (sys.exec_prefix, target_arch)
        )
    else:
        sys.exit("Error, cannot locate suitable C compiler.")

# Do we use C11 for source files, or pretend to be C++ as a workaround.
c11_mode = enableC11Settings(
    env=env,
    clangcl_mode=clangcl_mode,
    msvc_mode=msvc_mode,
    clang_mode=clang_mode,
    gcc_mode=gcc_mode,
    gcc_version=gcc_version,
)

if show_scons_mode:
    my_print("Scons: Using C11 mode:", c11_mode)

if show_scons_mode:
    my_print("Scons: Compiler used", end=" ")
    my_print(getExecutablePath(the_compiler, env=env), end=" ")

    if win_target and msvc_mode:
        my_print("(MSVC %s)" % getMsvcVersionString(env))

    my_print()

env["BUILD_DIR"] = source_dir

# Store the file signatures database with the rest of the source files
# and make it version dependent on the Python version of Scons, as its
# pickle is being used.
sconsign_dir = os.path.abspath(
    os.path.join(
        source_dir, ".sconsign-%d%s" % (sys.version_info[0], sys.version_info[1])
    )
)

if not os.path.exists(sconsign_dir):
    os.makedirs(sconsign_dir)

env.SConsignFile(sconsign_dir)

if gcc_mode:
    # Support for gcc and clang, restricting visibility as much as possible.
    if not win_target:
        env.Append(CCFLAGS=["-fvisibility=hidden"])
        env.Append(CXXFLAGS=["-fvisibility-inlines-hidden"])

    # Make it clear how to handle integer overflows, namely by wrapping around
    # to negative values.
    env.Append(CCFLAGS=["-fwrapv"])


# Support for clang.
if "clang" in the_cc_name:
    env.Append(CCFLAGS=["-w"])
    env.Append(CPPDEFINES=["_XOPEN_SOURCE"])

    # Don't export anything by default, this should create smaller executables.
    env.Append(CCFLAGS=["-fvisibility=hidden", "-fvisibility-inlines-hidden"])

    if debug_mode:
        env.Append(CCFLAGS=["-Wunused-but-set-variable"])

# Support details for real g++, not clang++.
if gcc_mode and "clang" not in the_cc_name:
    # Enforce the minimum version, selecting a potentially existing g++-4.5
    # binary if it's not high enough. This is esp. useful under Debian which
    # allows all compiler to exist next to each other and where g++ might not be
    # good enough, but g++-4.5 would be.
    if gcc_version < (4, 4):
        sys.exit(
            """\
The gcc compiler %s (version %s) doesn't have the sufficient \
version (>= 4.4)."""
            % (the_compiler, gcc_version)
        )

    # CondaCC or newer.
    if mingw_mode and gcc_version < (5, 3):
        sys.exit(
            """\
The MinGW64 compiler %s (version %s) doesn't have the sufficient \
version (>= 5.3)."""
            % (the_compiler, gcc_version)
        )

    # Older g++ complains about aliasing with Py_True and Py_False, but we don't
    # care.
    if gcc_version < (4, 5):
        env.Append(CCFLAGS=["-fno-strict-aliasing"])

    # For LTO mode, the version requirement is even higher, so try that too.
    if lto_mode and gcc_version < (4, 6):
        sys.exit(
            """\
The gcc compiler %s (version %s) doesn't have the sufficient \
version for lto mode (>= 4.6)."""
            % (env["CXX"], env["CXXVERSION"])
        )

    if lto_mode and mingw_mode:
        sys.exit("""The gcc compiler on Windows, doesn't currently support lto mode.""")

    # For gcc 4.6 there are some new interesting functions.
    if gcc_version >= (4, 6):
        env.Append(CCFLAGS=["-fpartial-inlining"])

        if debug_mode:
            env.Append(CCFLAGS=["-Wunused-but-set-variable"])

    # Use link time optimizations so that gcc can help with optimization across
    # files, but unfortunately at this time it seriously slows down the compiled
    # code. This may be because it needs -O3 option to be effective.

    if lto_mode and gcc_version >= (4, 6):
        env.Append(CCFLAGS=["-flto"])
        env.Append(LINKFLAGS=["-flto=%d" % job_count])

        if debug_mode:
            env.Append(LINKFLAGS=["-O2"])

        env.Append(LINKFLAGS=["-O3", "-fpartial-inlining", "-freorder-functions"])

    # Save some memory for gcc by not tracing macro code locations at all.
    if gcc_version >= (5,) and not debug_mode and not clang_mode:
        env.Append(CCFLAGS=["-ftrack-macro-expansion=0"])

    # We don't care about that.
    env.Append(CCFLAGS=["-Wno-deprecated-declarations"])

    # Give a warning if LTO mode was specified, but won't be used.
    if lto_mode and gcc_version < (4, 6):
        my_print("Warning, LTO mode specified, but not available.", file=sys.stderr)

    # The var-tracking does not scale, disable it. Should we really need it, we
    # can enable it. TODO: Does this cause a performance loss?
    env.Append(CCFLAGS=["-fno-var-tracking"])

# Avoid them as appearing to be different files. TODO: Find out which
# clang version has this, clang-8 does not.
if gcc_mode and not clang_mode and gcc_version >= (8,):
    if source_dir != "." and not full_names:
        # TODO: This also lies for modules codes.
        env.Append(
            CCFLAGS=[
                "--file-prefix-map=%s=%s" % (os.path.normpath(source_dir), "."),
                "--file-prefix-map=%s=%s"
                % (
                    os.path.normpath(os.path.join(source_dir, "static_src")),
                    os.path.normpath(os.path.join(nuitka_src, "static_src")),
                ),
            ]
        )

if msvc_mode:
    # With Clang on Windows, there is also an linker to use.
    env.Append(
        CCFLAGS=[
            "/EHsc",  # No C++ exception handling code.
            "/J",  # default char type is unsigned.
            "/Gd",  # Use C calling convention by default.
            "/bigobj",  # Product object files with larger internal limits.
        ]
    )

    # No incremental linking.
    env.Append(LINKFLAGS=["/INCREMENTAL:NO"])

# The MinGW64 does not default for API level properly, so help it.
if mingw_mode:
    # Windows XP
    env.Append(CPPDEFINES=["_WIN32_WINNT=0x0501"])

# At least older MinGW64 has issues with this, so disable it.
if mingw_mode and gcc_version < (6,) and not clang_mode:
    env.Append(LINKFLAGS=["-Wl,--no-gc-sections"])

if debug_mode:
    if gcc_mode:
        # Allow gcc/clang to point out all kinds of inconsistency to us by
        # raising an error.
        env.Append(
            CCFLAGS=[
                "-Wall",
                "-Werror",
                # Unfortunately Py_INCREF(Py_False) triggers aliasing warnings,
                # which are unfounded, so disable them.
                "-Wno-error=strict-aliasing",
                "-Wno-strict-aliasing",
                # At least for self-compiled Python3.2, and MinGW this happens
                # and has little use anyway.
                "-Wno-error=format",
                "-Wno-format",
            ]
        )

        if not clang_mode and gcc_version >= (6,):
            env.Append(
                CCFLAGS=[
                    # For large files, these can issue warnings about disabling
                    # itself, while we do not need it
                    "-Wno-misleading-indentation"
                ]
            )
    elif msvc_mode:
        # Disable warnings that system headers already show.
        env.Append(
            CCFLAGS=[
                "/W4",
                "/wd4505",
                "/wd4127",
                "/wd4100",
                "/wd4702",
                "/wd4189",
                "/wd4211",
                "/WX",
            ]
        )

        # Disable warnings, that CPython headers already show.
        env.Append(CCFLAGS=["/wd4512", "/wd4510", "/wd4610"])

if experimental:
    env.Append(
        CPPDEFINES=[
            "_NUITKA_EXPERIMENTAL_" + experiment.upper().replace("-", "_")
            for experiment in experimental
            if experiment
        ]
    )

if trace_mode:
    env.Append(CPPDEFINES=["_NUITKA_TRACE"])


# For MinGW and cross compilation, we need to tell the subsystem
# to target as well as to automatically import everything used.
if gcc_mode:
    if not clang_mode:
        env.Append(LINKFLAGS=["-Wl,--enable-auto-import"])

    if win_disable_console:
        env.Append(LINKFLAGS=["-Wl,--subsystem,windows"])

if win_disable_console:
    env.Append(CPPDEFINES=["_NUITKA_WINMAIN_ENTRY_POINT"])

# For shell API usage to lookup app folders we need this.
if msvc_mode:
    env.Append(LIBS=["Shell32"])

# The static include files reside in Nuitka installation, which may be where
# the "nuitka.build" package lives.
nuitka_include = os.path.join(nuitka_src, "include")

if not os.path.exists(os.path.join(nuitka_include, "nuitka", "prelude.h")):
    sys.exit(
        "Error, cannot locate Nuitka includes at '%s', broken installation."
        % nuitka_include
    )

# We have include files in the build directory and the static include directory
# that is located inside Nuitka installation.
env.Append(CPPPATH=[source_dir, nuitka_include, os.path.join(nuitka_src, "static_src")])

if debug_mode or unstripped_mode:
    # Use debug format, so we get good tracebacks from it.
    if gcc_mode:
        env.Append(CCFLAGS=["-g"])
        env.Append(ASFLAGS=["-g"])

        if not clang_mode:
            env.Append(CCFLAGS=["-feliminate-unused-debug-types"])
    elif msvc_mode:
        env.Append(CCFLAGS=["/Z7"])

        # Higher MSVC versions need this for parallel compilation
        if job_count > 1 and getMsvcVersion(env) >= 11:
            env.Append(CCFLAGS=["/FS"])

        env.Append(LINKFLAGS=["/DEBUG"])
else:
    if gcc_mode:
        if not clang_mode:
            env.Append(LINKFLAGS=["-s"])

# When debugging, optimize less than when optimizing, when not remove
# assertions.
if debug_mode:
    if gcc_mode or msvc_mode:
        env.Append(CCFLAGS=["-O2"])
else:
    if gcc_mode:
        env.Append(CCFLAGS=["-O3"])

        # Check inlining of calls, except in debug mode, where it will all be
        # wrong due to additional code.
        # if not debug_mode:
        #     env.append(CCFLAGS = ["-Winline"])
    elif msvc_mode:
        env.Append(
            CCFLAGS=[
                "/Ox",  # Enable most speed optimization
                "/GF",  # Eliminate duplicate strings.
                "/Gy",  # Function level object storage, to allow removing unused ones
            ]
        )

    env.Append(CPPDEFINES=["__NUITKA_NO_ASSERT__"])

# Tell compiler to create a program.
if msvc_mode:
    env.Append(CCFLAGS=["/MT"])  # Multithreaded, static version of C run time.


def discoverSourceFiles():
    result = []

    # If we use C11 capable compiler, all good. Otherwise use C++, which Scons
    # needs to derive from filenames, so make copies (or links) with a different
    # name.
    def _scanSourcekDir(dirname):
        if not os.path.exists(dirname):
            return

        for filename in sorted(os.listdir(dirname)):
            # Only C files are of interest here.
            if not filename.endswith((".c", "cpp")) or not filename.startswith(
                ("module.", "__", "plugin.")
            ):
                continue

            filename = os.path.join(dirname, filename)

            target_file = filename

            # We pretend to use C++ if no C11 compiler is present.
            if c11_mode:
                result.append(filename)
            else:
                if filename.endswith(".c"):
                    target_file += "pp"  # .cpp" suffix then

                    os.rename(filename, target_file)

                result.append(target_file)

    # Scan for Nuitka created source files, and add them too.
    _scanSourcekDir(source_dir)
    _scanSourcekDir(os.path.join(source_dir, "plugins"))

    # Main onefile bootstrap program
    result.append(
        provideStaticSourceFile(
            sub_path="WindowsOnefile.c",
            nuitka_src=nuitka_src,
            source_dir=source_dir,
            c11_mode=c11_mode,
        )
    )

    return result


source_targets = []

source_files = discoverSourceFiles()

target = env.Program(result_exe, source_files + source_targets)

# Avoid dependency on MinGW libraries.
if win_target and gcc_mode and not clang_mode:
    env.Append(LINKFLAGS=["-static-libgcc"])

# Avoid IO for compilation as much as possible, this should make the
# compilation more memory hungry, but also faster.
if gcc_mode:
    env.Append(CCFLAGS="-pipe")

# Outside compiler settings are respected.
if "CPPFLAGS" in os.environ:
    if show_scons_mode:
        my_print("Scons: Inherited CPPFLAGS='%s' variable." % os.environ["CPPFLAGS"])
    env.Append(CPPFLAGS=os.environ["CPPFLAGS"].split())
if "CCFLAGS" in os.environ:
    if show_scons_mode:
        my_print("Scons: Inherited CCFLAGS='%s' variable." % os.environ["CCFLAGS"])
    env.Append(CCFLAGS=os.environ["CCFLAGS"].split())
if "CXXFLAGS" in os.environ:
    if show_scons_mode:
        my_print("Scons: Inherited CXXFLAGS='%s' variable." % os.environ["CXXFLAGS"])
    env.Append(CXXFLAGS=os.environ["CXXFLAGS"].split())

# Outside linker flags are respected.
if "LDFLAGS" in os.environ:
    if show_scons_mode:
        my_print("Scons: Inherited LDFLAGS='%s' variable." % os.environ["LDFLAGS"])
    env.Append(LINKFLAGS=os.environ["LDFLAGS"].split())

# Remove the target file to avoid cases where it falsely doesn't get rebuild
# and then lingers from previous builds,
if os.path.exists(target[0].abspath):
    os.unlink(target[0].abspath)

if show_scons_mode:
    my_print("Scons: Told to run compilation on %d CPUs." % job_count)

if show_scons_mode:
    my_print("Scons: Launching target:", target)

# Plugin contributed C defines should be used too.
env.Append(CPPDEFINES=cpp_defines)
# Plugin contributed link libraries should be used too.
env.Append(LIBS=link_libraries)

# Work around windows bugs and use watchdogs to track progress of compilation.
if win_target:
    env["SPAWN"] = getWindowsSpawnFunction(
        module_mode=module_mode, lto_mode=lto_mode, source_files=source_files
    )
else:
    env["SPAWN"] = getWrappedSpawnFunction(env["SPAWN"])

# Before we go, also lets turn KeyboardInterrupt into a mere error exit as the
# scons traceback is not going to be very interesting to us.
changeKeyboardInteruptToErrorExit()

# Check if ccache is installed, and complain if it is not.
if gcc_mode:
    if enableCcache(
        the_compiler=the_compiler,
        env=env,
        source_dir=source_dir,
        python_prefix=python_prefix,
        show_scons_mode=show_scons_mode,
        assume_yes_for_downloads=assume_yes_for_downloads,
    ):
        cache_mode = False

if msvc_mode:
    if enableClcache(
        the_compiler=the_compiler,
        env=env,
        source_dir=source_dir,
        python_prefix=python_prefix,
        show_scons_mode=show_scons_mode,
    ):
        cache_mode = False

onefile_definitions = {
    "ONEFILE_COMPANY": os.environ["ONEFILE_COMPANY"],
    "ONEFILE_PRODUCT": os.environ["ONEFILE_PRODUCT"],
    "ONEFILE_VERSION": os.environ["ONEFILE_VERSION"],
}

createDefinitionsFile(source_dir, "onefile_definitions.h", onefile_definitions)

# Caching bv scons if necessary, i.e. no ccache available, when done, by the fastest
# possible algorithm and right inside the build directory. Makes no sense of course,
# if that is removed later on by Nuitka, so in that case, this is passed as false,
# to begin with.
if cache_mode:
    if show_scons_mode:
        my_print("Scons: Using scons cache inside build directory.")

    CacheDir(os.path.join(source_dir, "cache-" + target_arch))
    Decider("MD5-timestamp")


writeSconsReport(
    source_dir=source_dir,
    env=env,
    gcc_mode=gcc_mode,
    clang_mode=clang_mode,
    msvc_mode=msvc_mode,
    clangcl_mode=clang_clmode,
)

Default(target)
